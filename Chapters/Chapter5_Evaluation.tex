\clearpage % clear the prior chapter's page

\chapter{Experiments}\label{CH5_Experiments}
%\vspace{-7mm}
%\bigskip


To evaluate \mytool, we ask the following questions: 
\begin{enumerate}
    \item RQ1: How applicable is \mytool?
    \item RQ2: How accurate is \mytool when performing failing test minimization?
\end{enumerate}

\section{Subjects}
We want to use any existing C\# bug repositories like Defects4J for our evaluation~\cite{just2014defects4j}. We are unaware of any such repository. Even the benchmark list on the program repair website, does not mention any C\# benchmarks~\cite{aprbenchmarks}. We used 5 open source C\# projects listed in Table~\ref{tab:avgimproved1}. These projects are \texttt{language-ext}~\cite{louth}, \texttt{Umbraco-CMS}~\cite{deminick}, \texttt{Fleck}~\cite{staten}, \texttt{BizHawk}~\cite{adelikat}, and \texttt{Skclusive.Mobx.Observable}~\cite{skclusive}. Among the five, all except \texttt{Skclusive.Mobx.Observable} are under active development.   
After selecting the subjects, we looked for existing bugs in those projects. We went through commits to see if any of the commits or any snapshot of the software had a failing test. It seems that conscious developers normally run unit tests before committing to the repository and, hence, we cannot find failing tests in any snapshot of the repository. We then searched for commits whose description seems to be associated with some bug. We used the current version of their source code and attempted to undo the commit that seemed to be bug fixes by changing the code by hand, hoping to regenerate a bug. Sometimes we need to utilize more than one related commit to recreate a bug. When a particular reversal of source code produced a failing test case, we preserved those changes as a bug and noted the failing test. The bugs (failing tests) that we have are based on commits but we hesitate to call them real bugs. We will call them synthetic bugs instead and hope that they bear a close resemblance to real bugs. The synthetic bugs seem to be a good intermediate solution between real bugs and mutants. 

Once we have a failing test, we need to ensure that it has at least one removable component in it - a statement, a block of code or a part of an expression statement such that after it is removed the test continues to fail the exact same way. We prune the failing test if we don't find any such component. Applying \mytool is meaningless if there are no removable components as it will not reduce anything.  

Using this process, we created 30 synthetic bugs that had 30 failing tests that are reducible.  

\section{Process}
For each failing test, we manually found a minimal test that still continues to fail the same way. As \emph{developer-written} unit tests are simple enough to work with, it was not difficult to manually find minimal tests. For all 30 failing tests, we created minimal tests and built a \emph{gold standard} for comparison.
We then used \mytool to reduce the failing tests.

\section{Measurement}
In order to measure the results of the experiment, a comparison was made between the results generated by the tool and the gold standard for statistics. Matching each failing test in the gold standard with the corresponding failing test generated by \mytool. The following information was collected for each simplified unit test: 
\begin{enumerate}
    \item\emph{True-Positive} (TP) - Statements that are removed correctly and matches with the gold standard. 
    \item \emph{False-Positive} (FP) - Statements that are incorrectly removed. 
    \item \emph{False-Negative} (FN) - Statements that are missed but should have been removed. 
\end{enumerate}

Using this information, it is trivial to calculate the precision and recall and infer an analysis on the results.


\begin{table}
\caption{Subject projects, LOC (Line of Code), \# of tests, and total commits. }
\begin{center}
{\scriptsize
\begin{tabular}{|l|r|r|r|}
\hline
Project & LOC & \# Tests & \# Commits \\
\hline
\hline
{language-ext} & 318157 & 2610 & 3032\\
\hline
{Umbraco-CMS} & 156992 & 2637 & 42491\\
\hline
{Fleck} & 3576 & 92 & 237\\
\hline
{BizHawk} & 1686865 & 98 & 19860\\
\hline
{Skclusive.Mobx.Observable} & 7970 & 41 & 26\\
\hline

\end{tabular}
}
\end{center}
\label{tab:avgimproved1}
\end{table}

